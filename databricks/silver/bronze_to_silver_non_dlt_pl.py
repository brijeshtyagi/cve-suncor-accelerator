# Databricks notebook source
# Install libraries
%pip install pyyaml

# COMMAND ----------

# Import libraries
import datetime
import pyspark.sql.functions as F
from utilities.op_utilities import get_config, get_expectation_and_quarantine_rules, create_quarantine_records, send_records_to_quarantine, merge_data, deduplicate_data
from utilities.data_validation_funcs import unique_record_check, consent_check

# COMMAND ----------

# Get the pipeline parameters
config_file_path = dbutils.widgets.get("config_file_path")
params = get_config(config_file_path)

# Bronze to silver parameters
bronze_to_silver_params = params["silver_ingestion_details"]

bronze_schema = bronze_to_silver_params["source_bronze_schema"]
bronze_table = f"{bronze_schema}.{bronze_to_silver_params['source_bronze_table']}"

# Data validation check details
expectation_details = bronze_to_silver_params["data_check"]["expectations"]
expectation_rules = get_expectation_and_quarantine_rules(expectation_details)[
    "expectation_rules"
]
quarantine_rules = get_expectation_and_quarantine_rules(expectation_details)[
    "quarantine_rules"
]


consent_params = params["consent_process_details"]
check_consent = consent_params["consent_curtbl_needscheck"]
consent_schema = consent_params["consent_reference_database"]
consent_table = f"{consent_schema}.{consent_params['consent_reference_table']}"
consent_table_id = consent_params["consent_tbl_id_col"]
bronze_id = consent_params["consent_curtbl_col_join"]
bronze_record_date = consent_params["consent_curtbl_col_date"]

deduplicate_rows = bronze_to_silver_params["deduplicate_rows"]
partition_keys = bronze_to_silver_params["dedup_partitions_cols"]
datetime_column = bronze_to_silver_params["dedup_dt_col"]

if quarantine_rules != None:
    quarantine_check = True
else:
    quarantine_check = False

if deduplicate_rows == "True":
    deduplicate_rows = True
else:
    deduplicate_rows = False

if check_consent == "True":
    check_consent = True
else:
    check_consent = False

# Load type
load_type = bronze_to_silver_params["load_type"]

# Silver/quarantine table details
silver_schema = bronze_to_silver_params["silver_schema"]
silver_table = f"{silver_schema}.{bronze_to_silver_params['silver_table']}"

quarantine_schema = bronze_to_silver_params["quarantine_schema"]
quarantine_table = bronze_to_silver_params["quarantine_table"]

# COMMAND ----------

# SILVER LAYER
# Create the silver table with expectation/data validation rules in place
def get_valid_records(raw_df, quarantine_rules):
    valid_records = (
        raw_df.withColumn("is_quarantined", F.expr(quarantine_rules))
        .filter((F.col("is_quarantined") == False))
        .drop("is_quarantined")
    )
    return valid_records


# Get the raw bronze dataframe
raw_df = spark.table(bronze_table)

final_silver_df = None
final_quarantine_df = None


# Get the data validations being run
data_validations = [quarantine_check, deduplicate_rows, check_consent]

match data_validations:
    case [True, True, True]:

        # Create silver df
        valid_records = get_valid_records(raw_df, quarantine_rules)

        deduplicated_records = deduplicate_data(
            valid_records,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=False
        )

        consented_records = (
            consent_check(
                consent_table,
                deduplicated_records,
                consent_table_id,
                bronze_id,
                bronze_record_date
            )
            .filter(F.col("consent_check") == "Valid")
            .drop("consent_check")
        )

        final_silver_df = consented_records.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

        # Create quarantine df
        invalid_records = raw_df.withColumn(
            "is_quarantined", F.expr(quarantine_rules)
        ).filter((F.col("is_quarantined") == True))

        duplicated_records = deduplicate_data(
            raw_df,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=True
        )

        unconsented_records = (
            consent_check(
                consent_table, raw_df, consent_table_id, bronze_id, bronze_record_date
            )
            .filter(F.col("consent_check") == "Invalid")
            .drop("consent_check")
        )

        final_quarantine_df = invalid_records.unionByName(
            duplicated_records, allowMissingColumns=True
        ).unionByName(unconsented_records, allowMissingColumns=True)

    case [False, True, True]:
        # Create silver df
        deduplicated_records = deduplicate_data(
            raw_df,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=False
        )

        consented_records = (
            consent_check(
                consent_table,
                deduplicated_records,
                consent_table_id,
                bronze_id,
                bronze_record_date
            )
            .filter(F.col("consent_check") == "Valid")
            .drop("consent_check")
        )

        final_silver_df = consented_records.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

        # Create quarantine df
        duplicated_records = deduplicate_data(
            raw_df,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=True
        )

        unconsented_records = (
            consent_check(
                consent_table, raw_df, consent_table_id, bronze_id, bronze_record_date
            )
            .filter(F.col("consent_check") == "Invalid")
            .drop("consent_check")
        )
        final_quarantine_df = duplicated_records.unionByName(
            unconsented_records, allowMissingColumns=True
        )

    case [True, False, True]:
        # Create silver df
        valid_records = get_valid_records(raw_df, quarantine_rules)

        consented_records = (
            consent_check(
                consent_table,
                valid_records,
                consent_table_id,
                bronze_id,
                bronze_record_date
            )
            .filter(F.col("consent_check") == "Valid")
            .drop("consent_check")
        )

        final_silver_df = consented_records.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

        # Create quarantine df
        invalid_records = raw_df.withColumn(
            "is_quarantined", F.expr(quarantine_rules)
        ).filter((F.col("is_quarantined") == True))

        unconsented_records = (
            consent_check(
                consent_table, raw_df, consent_table_id, bronze_id, bronze_record_date
            )
            .filter(F.col("consent_check") == "Invalid")
            .drop("consent_check")
        )
        final_quarantine_df = invalid_records.unionByName(
            unconsented_records, allowMissingColumns=True
        )

    case [True, True, False]:
        # Create silver df
        valid_records = get_valid_records(raw_df, quarantine_rules)

        deduplicated_records = deduplicate_data(
            valid_records,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=False
        )

        final_silver_df = deduplicated_records.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

        # Create quarantine df
        invalid_records = raw_df.withColumn(
            "is_quarantined", F.expr(quarantine_rules)
        ).filter((F.col("is_quarantined") == True))

        duplicated_records = deduplicate_data(
            raw_df,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=True
        )

        final_quarantine_df = invalid_records.unionByName(
            duplicated_records, allowMissingColumns=True
        )

    case [True, False, False]:
        # Create silver df
        valid_records = get_valid_records(raw_df, quarantine_rules)

        final_silver_df = valid_records.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

        # Create quarantine df
        invalid_records = raw_df.withColumn(
            "is_quarantined", F.expr(quarantine_rules)
        ).filter((F.col("is_quarantined") == True))

        final_quarantine_df = invalid_records

    case [False, True, False]:
        # Create silver df
        deduplicated_records = deduplicate_data(
            raw_df,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=False
        )

        final_silver_df = deduplicated_records.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

        # Create quarantine df
        duplicated_records = deduplicate_data(
            raw_df,
            partition_columns=partition_keys,
            datetime_column=datetime_column,
            return_invalid=True
        )

        final_quarantine_df = duplicated_records

    case [False, False, True]:
        # Create silver df
        consented_records = (
            consent_check(
                consent_table, raw_df, consent_table_id, bronze_id, bronze_record_date
            )
            .filter(F.col("consent_check") == "Valid")
            .drop("consent_check")
        )

        final_silver_df = consented_records.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

        # Create quarantine df
        unconsented_records = (
            consent_check(
                consent_table, raw_df, consent_table_id, bronze_id, bronze_record_date
            )
            .filter(F.col("consent_check") == "Invalid")
            .drop("consent_check")
        )

        final_quarantine_df = unconsented_records

    case [False, False, False]:
        # Create silver df
        final_silver_df = raw_df.withColumn(
            "silver_last_modified_dt", F.lit(datetime.datetime.now())
        )

# Write to final silver and quarantine dataframes to the silver and quarantine tables
final_silver_df = final_silver_df.drop("bronze_last_modified_dt")
merge_data(final_silver_df, silver_table, operation=load_type)

if final_quarantine_df != None:
    rejected_records = create_quarantine_records(
        final_quarantine_df, "bronze", "failed data check", silver_table
    )
    send_records_to_quarantine(rejected_records, quarantine_schema, quarantine_table, "static")
