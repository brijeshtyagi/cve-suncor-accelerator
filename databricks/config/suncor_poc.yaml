data_pipeline_name: &MODULENAME "suncor_dbx_address" # The data pipeline name
description: "Sample YAML config for the DBX Accelerator Data Platform source to gold"
bronze_database: &DBBRONZE "suncor_bronze" # the bronze DB name
silver_database: &DBSILVER  "suncor_silver" # the silver DB name
gold_database: &DBGOLD "suncor_gold" # the gold DB name
bronze_ingestion_details:
  source_file_path: "abfss://erpsource@stsuncordev.dfs.core.windows.net/source1/Address/2023/07" # the file landing path dbutils.fs.ls("abfss://erpsource@stsuncordev.dfs.core.windows.net/source1")
  source_file_format: "csv" # the file format. either csv, json, parquet or, avro
  source_file_first_row_is_header: "True" # only required for csvs. either True or False
  source_file_delimiter: "|" # only required for csvs
  source_file_multiline: "" # only required for jsons
  bronze_schema: *DBBRONZE # the bronze DB name
  bronze_table: "bronze_address" # the name of the tables to be populated in bronze, silver, gold
consent_process_details: 
  #These are the fields for each individual table
  consent_curtbl_needscheck: "False" #If the table does not need to be consent checked, then set it to "False"
  consent_curtbl_col_date: "" #If table needs join, this can be left blank
  consent_tbl_id_col: "" # Column that contains unique participant
  consent_curtbl_col_participant_id: "" # Column that contains unique participant
  consent_curtbl_col_join: "" # Column in dependent table which will join with users table
  consent_reference_database: *DBGOLD # the DB name where the consent table is
  consent_reference_table: "" # the name of the consent table
silver_ingestion_details:
  source_bronze_schema: *DBBRONZE # the bronze DB name
  source_bronze_table: "bronze_address" # the bronze table name
  silver_schema: *DBSILVER # the silver DB name
  silver_table: "silver_address" # the silver table name
  quarantine_schema: "" # the quarantine DB name
  quarantine_table: "" # the quarantine table name
  load_type: "" # Load type from bronze to silver if using the non-dlt bronze to silver template, currently only "append" used
  deduplicate_rows: "False" # If using the non-dlt bronze to silver template, whether to deduplicate rows, either "True" or "False"
  dedup_partitions_cols: [""] # Columns to find duplicates with
  dedup_dt_col: "" # Datetime column to select the non duplicate record with
  data_check: # The data validation checks/expectations being implemented
    expectations:
silver_to_gold_details:
  silver_schema: *DBSILVER # the silver DB name
  silver_table: "silver_address" # the silver table name
  gold_schema: *DBGOLD # the gold DB name
  gold_table:  "gold_address" # the gold table name
  merge_id: "AddressID" # a list of the source table merge keys for the silver to gold SCD Type 2 logic
  logical_order: "silver_last_modified_dt" # the source table logical order field
de_identification_details:
  source_schema: *DBBRONZE # Source schema where the original sensitive data resides
  source_table:  "bronze_address" # Source table where the original sensitive data resides
  de_identification_schema: *DBSILVER # De-identification schema where the de-identified data will be stored
  de_identification_table: "silver_address" # De-identification table where the de-identified data will be stored
  de_identification_lookup_table:  "silver_address_lookup_table" # Lookup table to maintain mapping of original data to de-identified data
  deidentify_data: "True" # Flag indicating whether de-identification is enabled or not (True for enabled, False for disabled)
  deidentify_col: ["AddressLine1"] # Columns to be de-identified
  secret_scope_name: "suncor"
  secret_key_name: "address_key"