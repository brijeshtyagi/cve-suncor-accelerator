# Platform Setup

- [Platform Setup](#platform-setup)
  - [Prerequisites:](#prerequisites)
  - [Step 1: Setup Developer Machine](#step-1-setup-developer-machine)
  - [Step 2: Configuring OpenID Connect in Azure](#step-2-configuring-openid-connect-in-azure)
    - [References](#references)
  - [Step 3: Create Team AD Groups (Optional)](#step-3-create-team-ad-groups-optional)
  - [Step 4: Create GitHub Branch Protection Rules, Environments, Variables, and Secrets](#step-4-create-github-branch-protection-rules-environments-variables-and-secrets)
    - [References](#references-1)
  - [Step 5: Deploy Terraform and Platform Resources](#step-5-deploy-terraform-and-platform-resources)
  - [Step 6: Assign Team AD Groups Contributor Role on Resource Group](#step-6-assign-team-ad-groups-contributor-role-on-resource-group)
  - [Step 7: Create Databricks AD App and Databricks Secret Scope](#step-7-create-databricks-ad-app-and-databricks-secret-scope)
    - [References](#references-2)
  - [Step 8: Setup Databricks Unity Catalog Permissions](#step-8-setup-databricks-unity-catalog-permissions)
    - [References](#references-3)
  - [Step 9: Deploy Databricks Resources and Files](#step-9-deploy-databricks-resources-and-files)

## Prerequisites:

Make sure the following tools are installed on your local machine:

- [Azure CLI](https://learn.microsoft.com/en-us/cli/azure/install-azure-cli)
- [GitHub CLI](https://cli.github.com/)
- [Databricks CLI](https://learn.microsoft.com/en-us/azure/databricks/dev-tools/cli/databricks-cli)

## Step 1: Setup Developer Machine

1. Clone the repo to your local machine and `cd` into the repo directory
2. Login to Azure CLI: `az login` and set the default subscription: `az account set --subscription <subscription-id>`
3. Login to GitHub CLI: `gh auth login` and set the default repository: `gh repo set-default`

## Step 2: Configuring OpenID Connect in Azure

OpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Azure, without needing to store the Azure credentials as long-lived GitHub secrets.

To set up an Azure Login with OpenID Connect and use it in a GitHub Actions workflow, you'll need:

- An Azure Active Directory application, with a service principal that has **owner** access to your subscription
- An Azure Active Directory application configured with a federated credential to trust tokens issued by GitHub Actions to your GitHub repository

```bash
SUBSCRIPTION_ID=$(az account list --query '[?isDefault].id' --output tsv)
ENV="Dev"
GH_REPO="<organization name>/<repo name>"
GH_APP="GitHub-Suncor-Dev"

# create AD app
APP_ID=$(az ad app create \
    --display-name $GH_APP \
    --query appId \
    --output tsv)

# create federated credentials
az ad app federated-credential create \
    --id $APP_ID \
    --parameters \
    "{
        \"name\": \"gh-${ENV,,}-env\",
        \"issuer\": \"https://token.actions.githubusercontent.com\",
        \"subject\": \"repo:$GH_REPO:environment:${ENV,,}\",
        \"description\": \"GitHub $ENV Environment\",
        \"audiences\": [\"api://AzureADTokenExchange\"]
    }"

# create AD service principal
SP_ID=$(az ad sp create \
    --id $APP_ID \
    --query id \
    --output tsv)

# assign service principal 'Owner' role on subscription
az role assignment create \
    --assignee $SP_ID \
    --role Owner \
    --scope /subscriptions/$SUBSCRIPTION_ID
```

### References

- [Use the Azure login action with OpenID Connect](https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#use-the-azure-login-action-with-openid-connect)
- [Configuring OpenID Connect in Azure](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-azure)

## Step 3: Create Team AD Groups (Optional)

`GitHub-Suncor-Team-{ENV}` is used to grant access to Azure resources and Azure Key Vault secrets.

`GitHub-Suncor-DBAdmin-{ENV}` is used to grant access to Azure Synapse, Azure SQL Server and Azure SQL Database.

```bash
SUBSCRIPTION_ID=$(az account list --query '[?isDefault].id' --output tsv)
AD_GROUPS=("GitHub-Suncor-Team-Dev" "GitHub-Suncor-DBAdmin-Dev")
TEAM=("user1@company.com" "user2@company.com")
GH_APP="GitHub-Suncor-Dev"

for AD_GROUP in "${AD_GROUPS[@]}"; do
    # create AD group
    GROUP_ID=$(az ad group create \
        --display-name $AD_GROUP \
        --mail-nickname $AD_GROUP \
        --query appId \
        --output tsv)

    # add team members to group
    for MEMBER in "${TEAM[@]}"; do
        az ad group member add \
            --group $AD_GROUP \
            --member-id $(az ad user show --id $MEMBER --query id --output tsv)
    done

    # add GitHub AD app to group
    APP_ID=$(az ad sp list \
        --display-name $GH_APP \
        --query [].id \
        --output tsv)

    az ad group member add \
        --group $AD_GROUP \
        --member-id $APP_ID
done
```

## Step 4: Create GitHub Branch Protection Rules, Environments, Variables, and Secrets

You can configure environments with protection rules and secrets. A workflow job that references an environment must follow any protection rules for the environment before running or accessing the environment's secrets.

Each environment will be configured to store the Azure Client ID of the AD App for that environment, along with the workflow variables used to deploy the platform resources.

Clone the repo to your local machine and use the GitHub CLI to execute the script below.

```bash
TENANT_ID=$(az account list --query '[?isDefault].tenantId' --output tsv)
SUBSCRIPTION_ID=$(az account list --query '[?isDefault].id' --output tsv)
ENV="Dev"
GH_REPO="<organization name>/<repo name>"
GH_APP="GitHub-Suncor-Dev"
# replace with your preferred Azure region and naming convention
LOCATION="westus2"
TERRAFORM_RESOURCE_GROUP_NAME="rg-suncor-${ENV,,}-terraform"
TERRAFORM_STORAGE_ACCOUNT_NAME="stsuncor${ENV,,}terraform"
RESOURCE_GROUP_NAME="rg-suncor-${ENV,,}"
STORAGE_ACCOUNT_NAME="stsuncor${ENV,,}"
KEY_VAULT_NAME="kv-suncor-${ENV,,}"
SYNAPSE_NAME="synsuncor${ENV,,}"
SQL_SERVER_1_NAME="sqlsuncor${ENV,,}"
SQL_SERVER_2_NAME="sqlsuncor${ENV,,}2"
DATABRICKS_NAME="dbw-suncor-${ENV,,}"
ADF_NAME="adf-suncor-${ENV,,}"

# set current repo as default
gh repo set-default

# create branch protection rules for `main` branch
echo '{"required_status_checks":{"strict":true,"contexts":["Check Branch Status"]},"enforce_admins":true,"required_pull_request_reviews":{"dismiss_stale_reviews":true,"require_code_owner_reviews":true,"required_approving_review_count":1,"require_last_push_approval":true,"bypass_pull_request_allowances":{"users":[],"teams":[]}},"restrictions":null,"required_conversation_resolution":true}' |
    gh api --method PUT -H "Accept: application/vnd.github+json" /repos/$GH_REPO/branches/main/protection --input -

# create global variables and secrets used by all environments
gh secret set "AZURE_SUBSCRIPTION_ID" --body $SUBSCRIPTION_ID
gh secret set "AZURE_TENANT_ID" --body $TENANT_ID

# create GitHub environment
echo '{"deployment_branch_policy":{"protected_branches":true,"custom_branch_policies":false}}' |
    gh api --method PUT -H "Accept: application/vnd.github+json" repos/$GH_REPO/environments/${ENV,,} --input -

# add GitHub AD App ID to environment
APP_ID=$(az ad sp list \
    --display-name $GH_APP \
    --query [].appId \
    --output tsv)

# create environment specific variables and secrets
gh secret set "AZURE_CLIENT_ID" --env ${ENV,,} --body $APP_ID
gh variable set "LOCATION" --env ${ENV,,} --body $LOCATION
gh variable set "TERRAFORM_RESOURCE_GROUP_NAME" --env ${ENV,,} --body $TERRAFORM_RESOURCE_GROUP_NAME
gh variable set "TERRAFORM_STORAGE_ACCOUNT_NAME" --env ${ENV,,} --body $TERRAFORM_STORAGE_ACCOUNT_NAME
gh variable set "RESOURCE_GROUP_NAME" --env ${ENV,,} --body $RESOURCE_GROUP_NAME
gh variable set "STORAGE_ACCOUNT_NAME" --env ${ENV,,} --body $STORAGE_ACCOUNT_NAME
gh variable set "KEY_VAULT_NAME" --env ${ENV,,} --body $KEY_VAULT_NAME
gh variable set "SYNAPSE_NAME" --env ${ENV,,} --body $SYNAPSE_NAME
gh variable set "SQL_SERVER_1_NAME" --env ${ENV,,} --body $SQL_SERVER_1_NAME
gh variable set "SQL_SERVER_2_NAME" --env ${ENV,,} --body $SQL_SERVER_2_NAME
gh variable set "DATABRICKS_NAME" --env ${ENV,,} --body $DATABRICKS_NAME
gh variable set "ADF_NAME" --env ${ENV,,} --body $ADF_NAME
```

### References

- [Using environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment)
- [GitHub Environment REST API](https://docs.github.com/en/rest/deployments/environments)
- [GitHub Branch REST API](https://docs.github.com/en/rest/branches/branch-protection)

## Step 5: Deploy Terraform and Platform Resources

1. Update the backend and configurations files with the appropriate values from the previous steps:
   1. [`terraform/tf_backend/env/dev/backend.tfvars`](../terraform/tf_backend/env/dev/backend.tfvars)
   2. [`terraform/tf_backend/env/dev/configuration.tfvars`](../terraform/tf_backend/env/dev/configuration.tfvars)
   3. [`terraform/platform/env/dev/backend.tfvars`](../terraform/platform/env/dev/backend.tfvars)
   4. [`terraform/platform/env/dev/configuration.tfvars`](../terraform/platform/env/dev/configuration.tfvars)
2. Trigger `Deploy Platform` with `full` deployment type to deploy the platform resources

:rotating_light: The workflow will **fail** after the platform deployment job.

## Step 6: Assign Team AD Groups Contributor Role on Resource Group

```bash
SUBSCRIPTION_ID=$(az account list --query '[?isDefault].id' --output tsv)
AD_GROUPS=("GitHub-Suncor-Team-Dev" "GitHub-Suncor-DBAdmin-Dev")
RG_NAME="rg-suncor-dev"

for AD_GROUP in "${AD_GROUPS[@]}"; do
    GROUP_ID=$(az ad group show \
        --group $AD_GROUP \
        --query id \
        --output tsv)

    # assign group 'Contributor' role on resource group
    az role assignment create \
        --assignee $GROUP_ID \
        --role Contributor \
        --scope /subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RG_NAME
done
```

## Step 7: Create Databricks AD App and Databricks Secret Scope

The Databricks AD App will be used to authenticate from the Databricks workspace to the Azure Storage Account.

```bash
APP_NAME="DBX-Suncor-Dev"
ST_NAME="stsuncordev"
SECRET_NAME="databricks-sp-secret"
KV_NAME="kv-suncor-dev"

# create AD service principal and assign 'Storage Blob Data Contributor'
ST_ID=$(az storage account show \
    --name $ST_NAME \
    --query id \
    --output tsv)

APP_ID=$(az ad sp create-for-rbac \
    --name $APP_NAME \
    --role 'Storage Blob Data Contributor' \
    --scope $ST_ID \
    --query appId \
    --output tsv)

# add service principal secret to the key vault
az keyvault secret set \
    --name $SECRET_NAME \
    --vault-name $KV_NAME \
    --value $(az ad app credential reset \
        --id $APP_ID \
        --display-name $SECRET_NAME \
        --years 1 \
        --query password \
        --output tsv) \
    --content-type "text/plain" \
    --query attributes
```

### References

- [Connect to Azure Data Lake Storage Gen2](https://learn.microsoft.com/en-us/azure/databricks/getting-started/connect-to-azure-storage)
- [Secret scopes](https://learn.microsoft.com/en-us/azure/databricks/security/secrets/secret-scopes)
- [Databricks REST API](https://docs.databricks.com/api/azure/workspace/secrets/createscope)

## Step 8: Setup Databricks Unity Catalog Permissions

1. Log in to the [account console](https://accounts.azuredatabricks.net/)
2. Create a metastore
3. Assign OIDC AD App the Azure Databricks Account Admin Role
4. Create a new group called "suncor" and add the OIDC AD App to the group

### References

- [Create a Unity Catalog metastore](https://learn.microsoft.com/en-us/azure/databricks/data-governance/unity-catalog/create-metastore)
- [Get started using Unity Catalog](https://learn.microsoft.com/en-us/azure/databricks/data-governance/unity-catalog/get-started)

## Step 9: Deploy Databricks Resources and Files

1. Update the backend and configurations files with the appropriate values from the previous steps:
   1. [`terraform/databricks/env/dev/backend.tfvars`](../terraform/databricks/env/dev/backend.tfvars)
   2. [`terraform/databricks/env/dev/configuration.tfvars`](../terraform/databricks/env/dev/configuration.tfvars)
2. Trigger `Deploy Platform` with `full` deployment type to continue the deployment of the databricks workspace resources and files
